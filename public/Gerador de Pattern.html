<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CONTAINNER® - Pattern Generator</title>
    <!-- Tailwind CSS para um design rápido e responsivo -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Estilo customizado para o corpo da página e fontes */
        body {
            font-family: 'Inter', sans-serif;
        }
    </style>
    <!-- Importa a fonte Inter do Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
</head>
<body class="bg-[#646569] flex h-screen w-screen overflow-hidden">

    <main class="w-full h-full">
        <!-- Área de Preview do Padrão SVG (ocupa a tela inteira) -->
        <svg id="pattern-preview" class="w-full h-full" viewBox="0 0 1080 1080" preserveAspectRatio="xMidYMid meet"></svg>
    </main>

    <!-- Overlay de Instruções (sem fundo) -->
    <div class="fixed bottom-4 left-4 text-xs text-[#191919] font-mono">
        <p><strong class="font-bold">→</strong>&nbsp;&nbsp;&nbsp;Novo Padrão</p>
        <p><strong class="font-bold">←</strong>&nbsp;&nbsp;&nbsp;Padrão Anterior</p>
        <p><strong class="font-bold">S</strong>&nbsp;&nbsp;&nbsp;&nbsp;Exportar SVG</p>
        <p><strong class="font-bold">Clique</strong> Remover Bloco</p>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- CONSTANTES DE CONFIGURAÇÃO ---
            const SVG_NAMESPACE = "http://www.w3.org/2000/svg";
            const CANVAS_WIDTH = 1080;
            const CANVAS_HEIGHT = 1080;
            const RECT_COLOR = "#191919"; // Cor preta para os retângulos
            const BACKGROUND_COLOR = "#646569"; // Cor de fundo do canvas
            const OVERLAP = 4; // Sobreposição em pixels para evitar frisos/gaps de renderização

            // --- ELEMENTOS DO DOM ---
            const svgCanvas = document.getElementById('pattern-preview');
            
            // --- GERENCIAMENTO DE ESTADO (HISTÓRICO) ---
            let history = [];
            let historyIndex = -1;

            /**
             * Gera um número inteiro aleatório dentro de um intervalo.
             */
            const getRandomInt = (min, max) => {
                min = Math.ceil(min);
                max = Math.floor(max);
                return Math.floor(Math.random() * (max - min + 1)) + min;
            };

            /**
             * Adiciona os event listeners de interação (clique, hover) a um retângulo.
             */
            const addInteractionListeners = (rect) => {
                rect.style.cursor = 'pointer';

                rect.addEventListener('mouseover', () => rect.setAttribute('opacity', '0.7'));
                rect.addEventListener('mouseout', () => rect.setAttribute('opacity', '1'));

                rect.addEventListener('click', (event) => {
                    event.stopPropagation();
                    rect.remove();
                    // Atualiza o estado atual no histórico após a remoção
                    history[historyIndex] = svgCanvas.innerHTML;
                });
            };

            /**
             * Renderiza um padrão a partir do HTML do SVG, e re-aplica os listeners de interação.
             */
            const displayPatternFromHistory = () => {
                svgCanvas.innerHTML = history[historyIndex];
                svgCanvas.querySelectorAll('rect').forEach(addInteractionListeners);
            };
            
            /**
             * Gera um novo padrão de retângulos, o renderiza e o adiciona ao histórico.
             */
            const generateNewPattern = () => {
                const fragment = document.createDocumentFragment();
                const numberOfRects = getRandomInt(15, 40);

                for (let i = 0; i < numberOfRects; i++) {
                    const rect = document.createElementNS(SVG_NAMESPACE, 'rect');
                    const width = getRandomInt(50, 400);
                    const height = getRandomInt(50, 400);
                    const x = getRandomInt(-width / 2, CANVAS_WIDTH - width / 2);
                    const y = getRandomInt(-height / 2, CANVAS_HEIGHT - height / 2);
                    const rotation = getRandomInt(0, 1) * 90;

                    rect.setAttribute('x', x - OVERLAP / 2);
                    rect.setAttribute('y', y - OVERLAP / 2);
                    rect.setAttribute('width', width + OVERLAP);
                    rect.setAttribute('height', height + OVERLAP);
                    rect.setAttribute('fill', RECT_COLOR);
                    rect.setAttribute('shape-rendering', 'crispEdges');
                    rect.setAttribute('transform', `rotate(${rotation} ${x + width / 2} ${y + height / 2})`);
                    
                    addInteractionListeners(rect);
                    fragment.appendChild(rect);
                }
                
                svgCanvas.innerHTML = '';
                svgCanvas.appendChild(fragment);

                // Se o usuário navegou para trás e criou um novo padrão, o histórico futuro é descartado.
                history = history.slice(0, historyIndex + 1);
                
                // Adiciona o novo estado ao histórico
                history.push(svgCanvas.innerHTML);
                historyIndex = history.length - 1;
            };
            
            /**
             * Exporta o conteúdo atual do SVG como um arquivo .svg para download.
             */
            const exportSVG = () => {
                const svgToExport = svgCanvas.cloneNode(true);

                // Garante que todos os retângulos tenham opacidade 1 ao exportar, removendo o efeito de hover.
                svgToExport.querySelectorAll('rect').forEach(rect => {
                    rect.removeAttribute('opacity');
                });
                
                // Garante que o SVG exportado tenha o tamanho e a viewbox corretos (1080x1080)
                // Isso efetivamente "corta" o que está fora da área visível.
                svgToExport.setAttribute('viewBox', `0 0 ${CANVAS_WIDTH} ${CANVAS_HEIGHT}`);
                svgToExport.setAttribute('width', CANVAS_WIDTH);
                svgToExport.setAttribute('height', CANVAS_HEIGHT);
                svgToExport.setAttribute('xmlns', SVG_NAMESPACE);

                const svgData = new XMLSerializer().serializeToString(svgToExport);
                const blob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `pattern_${Date.now()}.svg`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            };

            // --- EVENT LISTENER DO TECLADO ---
            document.addEventListener('keydown', (event) => {
                switch (event.key) {
                    case 'ArrowRight':
                        // Se estiver no final do histórico, gera um novo padrão. Senão, avança.
                        if (historyIndex === history.length - 1) {
                            generateNewPattern();
                        } else {
                            historyIndex++;
                            displayPatternFromHistory();
                        }
                        break;
                    case 'ArrowLeft':
                        // Apenas volta se não estiver no início do histórico.
                        if (historyIndex > 0) {
                            historyIndex--;
                            displayPatternFromHistory();
                        }
                        break;
                    case 's':
                    case 'S':
                        exportSVG();
                        break;
                }
            });

            // --- INICIALIZAÇÃO ---
            generateNewPattern();
        });
    </script>
</body>
</html>

